<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Albums - Cloud AI Saliency</title>
    
    <style>
        body {
            margin: 0; padding: 0; background-color: #000; overflow: hidden;
            font-family: sans-serif; user-select: none; -webkit-user-select: none;
        }
        #container {
            position: relative; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden; background-color: #000; cursor: pointer; 
        }
        #bg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-size: cover; background-position: center;
            filter: blur(120px) brightness(0.9);
            transform: scale(1.4); z-index: 1; opacity: 0; transition: opacity 1s;
        }
        #art-wrapper {
            position: relative; z-index: 10; width: 90vmin; height: 90vmin;
            display: flex; box-shadow: 0 0 120px 10px rgba(0,0,0,0.5);
            border-radius: 24px; overflow: hidden; 
        }
        #album-art {
            width: 100%; height: 100%; object-fit: contain; 
            opacity: 0; transition: opacity 1s;
        }
        .crop-highlight {
            position: absolute; border: 4px solid red;
            box-shadow: 0 0 10px rgba(0,0,0,0.8);
            box-sizing: border-box; pointer-events: none; z-index: 20;
            opacity: 0; transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #debug-log {
            position: absolute; 
            top: calc(10px + env(safe-area-inset-top)); 
            left: max(10px, env(safe-area-inset-left)); 
            z-index: 999;
            color: #00ff00; font-family: monospace; font-size: 12px;
            background: rgba(0,0,0,0.8); padding: 8px; border-radius: 8px;
            pointer-events: none; max-width: 80vw; word-wrap: break-word;
        }
        #status-light {
            position: absolute; 
            top: calc(15px + env(safe-area-inset-top)); 
            right: max(15px, env(safe-area-inset-right)); 
            z-index: 1000;
            width: 16px; height: 16px; border-radius: 50%;
            background-color: #555; border: 2px solid #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
            cursor: pointer;
        }
        .ai-online { background-color: #00ff00 !important; box-shadow: 0 0 15px #00ff00 !important; }
        .ai-offline { background-color: #ff0000 !important; box-shadow: 0 0 15px #ff0000 !important; }
        .ai-waiting { background-color: #ffaa00 !important; box-shadow: 0 0 15px #ffaa00 !important; }
    </style>
</head>
<body>

    <div id="debug-log">Starting up...</div>
    <div id="status-light" title="Tap to reset token" onclick="resetToken()"></div>

    <div id="container">
        <div id="bg-layer"></div>
        <div id="art-wrapper">
            <img id="album-art" src="" alt="" crossorigin="anonymous" />
            </div>
        <video id="wake-video" playsinline loop muted width="1" height="1" style="opacity: 0; position: absolute;">
            <source src="data:video/mp4;base64,AAAAHGZ0eXBNNEVAAAAAAAEAAAAAAABtZGF0AAAAEAAACAAAABAAAAA=" type="video/mp4">
        </video>
    </div>

    <script>
        const CONFIG = {
            HF_API_TOKEN: localStorage.getItem('hf_token') || '', 
            HF_MODEL_ENDPOINT: "https://router.huggingface.co/hf-inference/models/facebook/detr-resnet-50",
            
            CSV_FILENAME: 'applemusic-3.csv', 
            CSV_INTERVAL_MS: 500000, 
            STORE_COUNTRY: 'il', 
            FADE_DURATION: 700, 
            BLACK_HOLD_DURATION: 200, 
            LAST_FM_API_KEY: '7a767d135623f2bac77d858b3a6d9aba',
            LAST_FM_USER: 'Noamsadi95',
            LAST_FM_POLL_INTERVAL: 5000, 
            LAST_FM_TIMEOUT_MS: 20 * 60 * 1000
        };

        let intervals = { lastFm: null, csv: null };
        let state = {
            startupDone: false, currentMode: 'STARTUP', csvTrackList: [], csvIndex: 0,
            displayedLastFmTrack: null, lastFmTrackStartTime: 0, lastFmActivityTime: Date.now(), isTransitioning: false
        };

        function resetToken() {
            if(confirm("Reset Hugging Face Token?")) {
                localStorage.removeItem('hf_token');
                location.reload();
            }
        }

        function setLight(status) {
            const light = document.getElementById('status-light');
            light.className = ''; 
            if (status) light.classList.add('ai-' + status);
        }

        function logStatus(msg) {
            console.log("[Status]", msg);
            const logEl = document.getElementById('debug-log');
            if (logEl) logEl.innerText = msg;
        }

        async function init() {
            logStatus("Initializing...");
            if (!CONFIG.HF_API_TOKEN) {
                const token = prompt("Enter Hugging Face API Token (hf_...):");
                if (token && token.trim() !== '') { 
                    localStorage.setItem('hf_token', token.trim()); 
                    CONFIG.HF_API_TOKEN = token.trim(); 
                } else {
                    logStatus("ERROR: API Token required.");
                    setLight('offline');
                    return;
                }
            }
            requestWakeLock();
            await loadCSV(); 
            checkLastFm(); 
            intervals.lastFm = setInterval(checkLastFm, CONFIG.LAST_FM_POLL_INTERVAL);
            setupInputListeners();
        }

        function setupInputListeners() {
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 's') triggerShuffle();
            });
            document.getElementById('container').addEventListener('click', (e) => {
                if(e.target.id !== 'status-light') triggerShuffle();
            });
        }

        function triggerShuffle() {
            if (state.isTransitioning) return;
            logStatus("Shuffle tapped!");
            if (state.currentMode !== 'CSV') startCsvMode();
            else {
                if (intervals.csv) clearInterval(intervals.csv);
                triggerCsvUpdate();
                intervals.csv = setInterval(triggerCsvUpdate, CONFIG.CSV_INTERVAL_MS);
            }
        }

        async function requestWakeLock() {
            try { if ('wakeLock' in navigator) await navigator.wakeLock.request('screen'); } catch (err) {}
        }

        function performVisualTransition(imageUrl, onSuccessCallback) {
            if (state.isTransitioning) return false; 
            state.isTransitioning = true;
            logStatus("Downloading Image...");

            // Clear old highlights instantly
            document.querySelectorAll('.crop-highlight').forEach(el => el.remove());

            const displayLoader = new Image();
            displayLoader.crossOrigin = "anonymous"; 
            displayLoader.src = imageUrl;

            displayLoader.onload = () => {
                const imgEl = document.getElementById('album-art');
                const bgEl = document.getElementById('bg-layer');
                if (!imgEl || !bgEl) return; 

                imgEl.src = imageUrl;
                bgEl.style.backgroundImage = `url('${imageUrl}')`;

                imgEl.style.opacity = '0';
                bgEl.style.opacity = '0';

                setTimeout(() => {
                    requestAnimationFrame(() => {
                        imgEl.style.opacity = '1';
                        bgEl.style.opacity = '1';
                        setTimeout(() => { 
                            state.isTransitioning = false;
                            if(onSuccessCallback) onSuccessCallback();
                            analyzeWithCloudAI(displayLoader, displayLoader.width, displayLoader.height);
                        }, CONFIG.FADE_DURATION);
                    });
                }, 100); 
            };
            displayLoader.onerror = () => {
                state.isTransitioning = false;
                logStatus("Error: Image failed to load.");
                setTimeout(triggerShuffle, 1000); 
            };
            return true;
        }

        // Helper function to prevent overlapping boxes on the same object
        function calculateIoU(box1, box2) {
            const xA = Math.max(box1.xmin, box2.xmin);
            const yA = Math.max(box1.ymin, box2.ymin);
            const xB = Math.min(box1.xmax, box2.xmax);
            const yB = Math.min(box1.ymax, box2.ymax);

            const interArea = Math.max(0, xB - xA) * Math.max(0, yB - yA);
            if (interArea === 0) return 0;

            const box1Area = (box1.xmax - box1.xmin) * (box1.ymax - box1.ymin);
            const box2Area = (box2.xmax - box2.xmin) * (box2.ymax - box2.ymin);

            return interArea / (box1Area + box2Area - interArea);
        }

        async function analyzeWithCloudAI(imgObj, imgW, imgH) {
            logStatus("Compressing for AI...");
            setLight('waiting');
            try {
                const canvas = document.createElement('canvas');
                const maxSize = 600; 
                let w = imgW, h = imgH;
                
                if (w > maxSize || h > maxSize) {
                    if (w > h) { h = Math.round((h * maxSize) / w); w = maxSize; } 
                    else { w = Math.round((w * maxSize) / h); h = maxSize; }
                }
                canvas.width = w; canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(imgObj, 0, 0, w, h);

                const imageBlob = await new Promise((resolve, reject) => {
                    canvas.toBlob((blob) => {
                        if (blob) resolve(blob);
                        else reject(new Error("Canvas block"));
                    }, 'image/jpeg', 0.8);
                });

                logStatus("Sending to Cloud AI...");

                const base64 = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(imageBlob);
                });

                const hfResponse = await fetch(CONFIG.HF_MODEL_ENDPOINT, {
                    headers: { 
                        "Authorization": `Bearer ${CONFIG.HF_API_TOKEN}`,
                        "Content-Type": "application/json"
                    },
                    method: "POST",
                    body: JSON.stringify({ inputs: `data:image/jpeg;base64,${base64}` }),
                });

                if (hfResponse.status === 401) {
                    localStorage.removeItem('hf_token');
                    throw new Error("Invalid Token. Tap red light to reset.");
                }

                if (!hfResponse.ok) throw new Error(`Server ${hfResponse.status}`);

                const result = await hfResponse.json();

                if (result.error && result.error.includes("is currently loading")) {
                    const waitTime = Math.ceil(result.estimated_time || 20);
                    logStatus(`AI Waking up... (${waitTime}s)`);
                    setLight('waiting');
                    setTimeout(() => analyzeWithCloudAI(imgObj, imgW, imgH), waitTime * 1000);
                    return;
                }

                if (Array.isArray(result) && result.length > 0) {
                    setLight('online');
                    
                    // Filter confident results, sort by score
                    const confidentSubjects = result
                        .filter(item => item.score > 0.40)
                        .sort((a, b) => b.score - a.score);
                        
                    const topSubjects = [];
                    
                    // Loop through and keep up to 3 subjects, discarding any that overlap heavily
                    for (const subject of confidentSubjects) {
                        let overlap = false;
                        for (const selected of topSubjects) {
                            // If a new box overlaps more than 30% with an existing one, ignore it
                            if (calculateIoU(subject.box, selected.box) > 0.30) {
                                overlap = true;
                                break;
                            }
                        }
                        if (!overlap) {
                            topSubjects.push(subject);
                            if (topSubjects.length >= 3) break;
                        }
                    }

                    // Fallback to the absolute best match if filtering wiped everything out
                    if (topSubjects.length === 0) topSubjects.push(result.sort((a, b) => b.score - a.score)[0]);

                    const labels = topSubjects.map(s => `${s.label}`).join(', ');
                    logStatus(`AI Focused on: ${labels}`);
                    
                    topSubjects.forEach((subject) => {
                        const box = subject.box;
                        const scaleX = imgW / w;
                        const scaleY = imgH / h;
                        
                        // Calculate center point
                        const centerX = (box.xmin + ((box.xmax - box.xmin) / 2)) * scaleX;
                        const centerY = (box.ymin + ((box.ymax - box.ymin) / 2)) * scaleY;
                        
                        // Calculate raw dimensions
                        const rawW = (box.xmax - box.xmin) * scaleX;
                        const rawH = (box.ymax - box.ymin) * scaleY;
                        
                        // STRICT SQUARE: Find the longest edge and add a little padding
                        const maxDimension = Math.max(rawW, rawH);
                        // Prevent the square from being bigger than the actual image
                        const squareSize = Math.min(maxDimension * 1.15, Math.min(imgW, imgH));
                        
                        const highlightElement = document.createElement('div');
                        highlightElement.className = 'crop-highlight';
                        document.getElementById('art-wrapper').appendChild(highlightElement);

                        applyAndClampBox(centerX, centerY, squareSize, squareSize, imgW, imgH, highlightElement);
                    });

                } else {
                    logStatus("No subjects. Centering.");
                    setLight('online');
                    const highlightElement = document.createElement('div');
                    highlightElement.className = 'crop-highlight';
                    document.getElementById('art-wrapper').appendChild(highlightElement);
                    applyAndClampBox(imgW/2, imgH/2, Math.min(imgW, imgH)*0.5, Math.min(imgW, imgH)*0.5, imgW, imgH, highlightElement);
                }
            } catch (error) {
                console.error("Cloud AI Error:", error);
                logStatus(`AI Failed: ${error.message}`);
                setLight('offline');
            }
        }

        function applyAndClampBox(centerX, centerY, targetWidth, targetHeight, imgW, imgH, el) {
            let startX = centerX - (targetWidth / 2);
            let startY = centerY - (targetHeight / 2);
            
            // Keeps the box strictly within the image bounds
            startX = Math.max(0, Math.min(imgW - targetWidth, startX));
            startY = Math.max(0, Math.min(imgH - targetHeight, startY));
            
            if (el) {
                el.style.left = (startX / imgW) * 100 + '%';
                el.style.top = (startY / imgH) * 100 + '%';
                el.style.width = (targetWidth / imgW) * 100 + '%';
                el.style.height = (targetHeight / imgH) * 100 + '%';
                el.style.opacity = '1';
            }
        }

        function startCsvMode() {
            if (state.currentMode === 'CSV' && intervals.csv) return;
            logStatus("CSV Mode Started");
            state.currentMode = 'CSV';
            if (intervals.csv) clearInterval(intervals.csv);
            triggerCsvUpdate(); 
            intervals.csv = setInterval(triggerCsvUpdate, CONFIG.CSV_INTERVAL_MS);
        }

        async function checkLastFm() {
            const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${CONFIG.LAST_FM_USER}&api_key=${CONFIG.LAST_FM_API_KEY}&format=json&limit=1`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.recenttracks && data.recenttracks.track.length > 0) {
                    const track = data.recenttracks.track[0];
                    const id = track.name + ' - ' + track.artist['#text'];
                    const playing = track['@attr'] && track['@attr'].nowplaying === 'true';
                    if (!state.startupDone) {
                        state.startupDone = true;
                        if (playing) switchToLastFm(track, id); else startCsvMode();
                        return;
                    }
                    if (playing) {
                        state.lastFmActivityTime = Date.now();
                        if (state.currentMode === 'CSV' || id !== state.displayedLastFmTrack) switchToLastFm(track, id);
                    } else if (state.currentMode === 'LASTFM' && (Date.now() - state.lastFmActivityTime > CONFIG.LAST_FM_TIMEOUT_MS)) {
                        startCsvMode();
                    }
                }
            } catch (e) { if (!state.startupDone) { state.startupDone = true; startCsvMode(); } }
        }

        function switchToLastFm(track, id) {
            if (intervals.csv) clearInterval(intervals.csv);
            state.currentMode = 'LASTFM';
            state.lastFmTrackStartTime = Date.now();
            logStatus("Playing: " + track.name);
            fetchItunesBySearch(track.name, track.artist['#text'], track.album['#text'], (url) => {
                if (!url && track.image) {
                    const img = track.image.find(i => i.size === 'extralarge') || track.image[track.image.length - 1];
                    url = img ? img['#text'] : null;
                }
                if (url) performVisualTransition(`https://wsrv.nl/?url=${encodeURIComponent(url)}`, () => { state.displayedLastFmTrack = id; });
            });
        }

        async function loadCSV() {
            try {
                const res = await fetch(CONFIG.CSV_FILENAME);
                if (!res.ok) throw new Error();
                const text = await res.text();
                const lines = text.split('\n').filter(l => l.trim() !== '');
                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                const idIdx = headers.indexOf('id');
                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(c => c.replace(/^"|"$/g, '').trim());
                    if (cols[idIdx]) state.csvTrackList.push({ id: cols[idIdx] });
                }
                state.csvTrackList.sort(() => Math.random() - 0.5);
                logStatus("CSV Loaded.");
            } catch (e) { logStatus("Using Fallback."); state.csvTrackList.push({ id: '617154241' }); }
        }

        function triggerCsvUpdate() {
            if (state.currentMode !== 'CSV' || !state.csvTrackList.length) return;
            const track = state.csvTrackList[state.csvIndex];
            fetchItunesById(track.id, (url) => {
                if (url) performVisualTransition(`https://wsrv.nl/?url=${encodeURIComponent(url)}`, null);
                else setTimeout(triggerCsvUpdate, 1000);
            });
            state.csvIndex = (state.csvIndex + 1) % state.csvTrackList.length;
        }

        function fetchItunesById(id, cb) {
            const n = 'cb' + Math.floor(Math.random() * 1e6);
            const s = document.createElement('script');
            s.src = `https://itunes.apple.com/lookup?id=${id}&country=${CONFIG.STORE_COUNTRY}&callback=${n}`;
            window[n] = (d) => { cleanup(s, n); cb(d.results?.[0]?.artworkUrl100?.replace('100x100bb', '1200x1200bb')); };
            s.onerror = () => { cleanup(s, n); cb(null); };
            document.body.appendChild(s);
        }

        function fetchItunesBySearch(t, a, al, cb) {
            const n = 'cb' + Math.floor(Math.random() * 1e6);
            const s = document.createElement('script');
            s.src = `https://itunes.apple.com/search?term=${encodeURIComponent(a+' '+t)}&entity=song&limit=1&country=${CONFIG.STORE_COUNTRY}&callback=${n}`;
            window[n] = (d) => { cleanup(s, n); cb(d.results?.[0]?.artworkUrl100?.replace('100x100bb', '1200x1200bb')); };
            s.onerror = () => { cleanup(s, n); cb(null); };
            document.body.appendChild(s);
        }

        function cleanup(s, n) { if(document.body.contains(s)) document.body.removeChild(s); delete window[n]; }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
