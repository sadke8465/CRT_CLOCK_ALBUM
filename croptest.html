<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Albums - AI Face Boost Test</title>
    
    <script src="https://unpkg.com/smartcrop@2.0.5/smartcrop.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: sans-serif;
            user-select: none; 
            -webkit-user-select: none;
        }
        #container {
            position: relative;
            width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden; background-color: #000;
            cursor: pointer; 
        }
        #bg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-size: cover; background-position: center;
            filter: blur(120px) brightness(0.9);
            transform: scale(1.4); z-index: 1; opacity: 0; transition: opacity 1s;
        }
        #art-wrapper {
            position: relative; z-index: 10;
            width: 90vmin; 
            height: 90vmin;
            display: flex;
            box-shadow: 0 0 120px 10px rgba(0,0,0,0.5);
            border-radius: 24px; overflow: hidden; 
        }
        #album-art {
            width: 100%; height: 100%; 
            object-fit: contain; 
            opacity: 0; transition: opacity 1s;
        }
        #crop-highlight {
            position: absolute;
            border: 4px solid red;
            box-shadow: 0 0 10px rgba(0,0,0,0.5), 0 0 0 9999px rgba(0, 0, 0, 0.4);
            box-sizing: border-box;
            pointer-events: none; 
            z-index: 20;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #debug-log {
            position: absolute; top: 10px; left: 10px; z-index: 999;
            color: #00ff00; font-family: monospace; font-size: 12px;
            background: rgba(0,0,0,0.6); padding: 8px; border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="debug-log">Starting up...</div>

    <div id="container">
        <div id="bg-layer"></div>
        <div id="art-wrapper">
            <img id="album-art" src="" alt="" />
            <div id="crop-highlight"></div>
        </div>
        <video id="wake-video" playsinline loop muted width="1" height="1" style="opacity: 0; position: absolute;">
            <source src="data:video/mp4;base64,AAAAHGZ0eXBNNEVAAAAAAAEAAAAAAABtZGF0AAAAEAAACAAAABAAAAA=" type="video/mp4">
        </video>
    </div>

    <script>
        const CONFIG = {
            CSV_FILENAME: 'applemusic-3.csv', 
            CSV_INTERVAL_MS: 500000, 
            STORE_COUNTRY: 'il', 
            FADE_DURATION: 700, 
            BLACK_HOLD_DURATION: 200, 
            LAST_FM_API_KEY: '7a767d135623f2bac77d858b3a6d9aba',
            LAST_FM_USER: 'Noamsadi95',
            LAST_FM_POLL_INTERVAL: 5000, 
            LAST_FM_TIMEOUT_MS: 20 * 60 * 1000
        };

        let intervals = { lastFm: null, csv: null };

        let state = {
            startupDone: false,
            currentMode: 'STARTUP', 
            csvTrackList: [],
            csvIndex: 0,
            displayedLastFmTrack: null,     
            lastFmTrackStartTime: 0,        
            lastFmActivityTime: Date.now(),
            isTransitioning: false
        };

        function logStatus(msg) {
            console.log("[Status]", msg);
            const logEl = document.getElementById('debug-log');
            if (logEl) logEl.innerText = msg;
        }

        async function init() {
            logStatus("Initializing...");
            requestWakeLock();
            
            await loadAIModels(); 
            
            await loadCSV(); 
            checkLastFm(); 
            intervals.lastFm = setInterval(checkLastFm, CONFIG.LAST_FM_POLL_INTERVAL);
            setupInputListeners();
        }

        async function loadAIModels() {
            logStatus("Loading AI Face Models...");
            try {
                const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
                await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
                logStatus("AI Models Loaded!");
            } catch (e) {
                logStatus("AI Model Load Failed!");
                console.error("Model Error:", e);
            }
        }

        function setupInputListeners() {
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 's') triggerShuffle();
            });
            document.getElementById('container').addEventListener('click', () => {
                triggerShuffle();
            });
        }

        function triggerShuffle() {
            if (state.isTransitioning) return;
            logStatus("Shuffle tapped!");
            if (state.currentMode !== 'CSV') {
                startCsvMode();
            } else {
                if (intervals.csv) clearInterval(intervals.csv);
                triggerCsvUpdate();
                intervals.csv = setInterval(triggerCsvUpdate, CONFIG.CSV_INTERVAL_MS);
            }
        }

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) await navigator.wakeLock.request('screen');
            } catch (err) {}
        }

        function performVisualTransition(imageUrl, onSuccessCallback) {
            if (state.isTransitioning) return false; 
            state.isTransitioning = true;
            logStatus("Downloading Image...");

            const displayLoader = new Image();
            displayLoader.src = imageUrl;

            displayLoader.onload = () => {
                logStatus("Image ready. Displaying...");
                const imgEl = document.getElementById('album-art');
                const bgEl = document.getElementById('bg-layer');
                const cropHighlight = document.getElementById('crop-highlight');

                if (!imgEl || !bgEl) return; 

                imgEl.style.opacity = '0';
                bgEl.style.opacity = '0';
                if(cropHighlight) {
                    cropHighlight.style.opacity = '0';
                    cropHighlight.style.borderColor = 'yellow'; 
                }

                setTimeout(() => {
                    imgEl.src = imageUrl;
                    bgEl.style.backgroundImage = `url('${imageUrl}')`;

                    requestAnimationFrame(() => {
                        imgEl.style.opacity = '1';
                        bgEl.style.opacity = '1';
                        
                        setTimeout(() => { 
                            state.isTransitioning = false;
                            if(onSuccessCallback) onSuccessCallback();
                            
                            // Start the AI analysis in the background
                            runSmartCropWithAI(imageUrl, cropHighlight);

                        }, CONFIG.FADE_DURATION);
                    });
                }, 100); 
            };

            displayLoader.onerror = () => {
                state.isTransitioning = false;
                logStatus("Error: Display image failed to load.");
                setTimeout(triggerShuffle, 1000); 
            };

            return true;
        }

        // --- THE UPDATED LOGIC ENGINE ---
        async function runSmartCropWithAI(originalUrl, highlightElement) {
            logStatus("Starting AI Scan...");
            const proxyLoader = new Image();
            proxyLoader.crossOrigin = "Anonymous";
            proxyLoader.src = `https://wsrv.nl/?url=${encodeURIComponent(originalUrl)}`;

            proxyLoader.onload = async () => {
                // We want our box to be exactly 50% of the image size
                const targetWidth = proxyLoader.width * 0.5;
                const targetHeight = proxyLoader.height * 0.5;
                
                let faces = [];

                try {
                    faces = await faceapi.detectAllFaces(proxyLoader, new faceapi.TinyFaceDetectorOptions());
                } catch (e) {
                    console.error("AI Scan failed", e);
                }

                if (faces.length > 0) {
                    logStatus(`Faces found: ${faces.length}. Snapping to face!`);
                    
                    // 1. Find the boundaries of ALL faces combined
                    let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
                    faces.forEach(face => {
                        if (face.box.x < minX) minX = face.box.x;
                        if (face.box.y < minY) minY = face.box.y;
                        if (face.box.x + face.box.width > maxX) maxX = face.box.x + face.box.width;
                        if (face.box.y + face.box.height > maxY) maxY = face.box.y + face.box.height;
                    });

                    // 2. Find the exact center point between all those faces
                    const faceCenterX = minX + ((maxX - minX) / 2);
                    const faceCenterY = minY + ((maxY - minY) / 2);

                    // 3. Center our 50% box over that point
                    let startX = faceCenterX - (targetWidth / 2);
                    let startY = faceCenterY - (targetHeight / 2);

                    // 4. Clamp the box so it doesn't slide off the edges of the album
                    startX = Math.max(0, Math.min(proxyLoader.width - targetWidth, startX));
                    startY = Math.max(0, Math.min(proxyLoader.height - targetHeight, startY));

                    applyCropBox(startX, startY, targetWidth, targetHeight, proxyLoader.width, proxyLoader.height, highlightElement);

                } else {
                    logStatus("No faces. Using SmartCrop Fallback.");
                    
                    // 1. Ask SmartCrop to find a 150x150 focal point
                    smartcrop.crop(proxyLoader, { width: 150, height: 150 }).then(result => {
                        const crop = result.topCrop;
                        
                        // 2. Find the exact center of that focal area
                        const focalX = crop.x + (crop.width / 2);
                        const focalY = crop.y + (crop.height / 2);

                        // 3. Center our 50% box over that point
                        let startX = focalX - (targetWidth / 2);
                        let startY = focalY - (targetHeight / 2);

                        // 4. Clamp the box so it doesn't slide off the edges
                        startX = Math.max(0, Math.min(proxyLoader.width - targetWidth, startX));
                        startY = Math.max(0, Math.min(proxyLoader.height - targetHeight, startY));

                        applyCropBox(startX, startY, targetWidth, targetHeight, proxyLoader.width, proxyLoader.height, highlightElement);
                    }).catch(err => logStatus("SmartCrop Failed."));
                }
            };

            proxyLoader.onerror = () => {
                logStatus("Error: Proxy image blocked for AI.");
            };
        }

        // Helper to draw the red box
        function applyCropBox(x, y, w, h, imgW, imgH, el) {
            const leftPct = (x / imgW) * 100;
            const topPct = (y / imgH) * 100;
            const widthPct = (w / imgW) * 100;
            const heightPct = (h / imgH) * 100;

            if (el) {
                el.style.borderColor = 'red';
                el.style.left = leftPct + '%';
                el.style.top = topPct + '%';
                el.style.width = widthPct + '%';
                el.style.height = heightPct + '%';
                el.style.opacity = '1';
            }
        }

        // --- HELPER: START CSV MODE ---
        function startCsvMode() {
            if (state.currentMode === 'CSV' && intervals.csv) return;
            logStatus("Starting CSV Mode");
            state.currentMode = 'CSV';
            if (intervals.csv) clearInterval(intervals.csv);
            triggerCsvUpdate(); 
            intervals.csv = setInterval(triggerCsvUpdate, CONFIG.CSV_INTERVAL_MS);
        }

        // --- LAST.FM LOGIC ---
        async function checkLastFm() {
            const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${CONFIG.LAST_FM_USER}&api_key=${CONFIG.LAST_FM_API_KEY}&format=json&limit=1`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.recenttracks && data.recenttracks.track && data.recenttracks.track.length > 0) {
                    const track = data.recenttracks.track[0];
                    const trackIdentifier = track.name + ' - ' + track.artist['#text'];
                    const isNowPlaying = track['@attr'] && track['@attr'].nowplaying === 'true';

                    if (!state.startupDone) {
                        state.startupDone = true;
                        if (isNowPlaying) switchToLastFm(track, trackIdentifier);
                        else startCsvMode();
                        return; 
                    }

                    if (isNowPlaying) {
                        state.lastFmActivityTime = Date.now();
                        if (state.currentMode === 'CSV') {
                            if (intervals.csv) clearInterval(intervals.csv);
                            switchToLastFm(track, trackIdentifier);
                        } else if (trackIdentifier !== state.displayedLastFmTrack) {
                            switchToLastFm(track, trackIdentifier);
                        }
                    } else if (state.currentMode === 'LASTFM' && (Date.now() - state.lastFmActivityTime > CONFIG.LAST_FM_TIMEOUT_MS)) {
                        startCsvMode();
                    }
                }
            } catch (error) {
                if (!state.startupDone) {
                    state.startupDone = true;
                    startCsvMode();
                }
            }
        }

        function switchToLastFm(track, trackIdentifier) {
            state.currentMode = 'LASTFM';
            state.lastFmTrackStartTime = Date.now();
            logStatus("Last.fm: " + track.name);

            const albumName = (track.album && track.album['#text']) ? track.album['#text'] : null;

            fetchItunesBySearch(track.name, track.artist['#text'], albumName, (itunesImageUrl) => {
                let finalImage = itunesImageUrl;
                if (!finalImage && track.image) {
                    const imgObj = track.image.find(i => i.size === 'extralarge') || track.image[track.image.length - 1];
                    if (imgObj) finalImage = imgObj['#text'];
                }
                if (finalImage) {
                    performVisualTransition(finalImage, () => {
                        state.displayedLastFmTrack = trackIdentifier;
                    });
                } else {
                    logStatus("No artwork found.");
                }
            });
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        async function loadCSV() {
            try {
                const response = await fetch(CONFIG.CSV_FILENAME);
                if (!response.ok) throw new Error("Fetch failed"); 
                parseCSV(await response.text());
                logStatus("CSV Loaded.");
            } catch (error) { 
                logStatus("CSV Blocked. Using Fallback.");
                state.csvTrackList.push({ id: '617154241' });
            }
        }

        function parseCSV(text) {
            const lines = text.split('\n').filter(l => l.trim() !== '');
            if (lines.length < 2) return;
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            const idIndex = headers.indexOf('id');
            if (idIndex === -1) return;
            const splitRegex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/;

            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(splitRegex).map(c => c.replace(/^"|"$/g, '').trim());
                if (cols.length > idIndex) state.csvTrackList.push({ id: cols[idIndex] });
            }
            if (state.csvTrackList.length > 0) shuffleArray(state.csvTrackList);
        }

        function triggerCsvUpdate() {
            if (state.currentMode !== 'CSV') return;
            if (state.csvTrackList.length === 0) return;

            const track = state.csvTrackList[state.csvIndex];
            if(!track) return; 

            logStatus("Fetching Apple Music Data...");
            fetchItunesById(track.id, (url) => {
                if (url) performVisualTransition(url);
                else {
                     state.csvIndex = (state.csvIndex + 1) % state.csvTrackList.length;
                     setTimeout(triggerCsvUpdate, 1000); 
                }
            });
            state.csvIndex = (state.csvIndex + 1) % state.csvTrackList.length;
        }

        function fetchItunesById(appleId, callback) {
            const cbName = 'cb_id_' + Math.floor(Math.random() * 100000);
            const script = document.createElement('script');
            script.src = `https://itunes.apple.com/lookup?id=${appleId}&country=${CONFIG.STORE_COUNTRY}&callback=${cbName}`;
            window[cbName] = function(data) {
                cleanupScript(script, cbName);
                if (data && data.results && data.results.length > 0) {
                    callback(data.results[0].artworkUrl100.replace('100x100bb', '1200x1200bb')); 
                } else callback(null);
            };
            script.onerror = () => { cleanupScript(script, cbName); callback(null); };
            document.body.appendChild(script);
        }

        function fetchItunesBySearch(trackName, artistName, albumName, callback) {
            const cbName = 'cb_search_' + Math.floor(Math.random() * 100000);
            let query = artistName + ' ' + trackName;
            if (albumName) query += ' ' + albumName;
            const script = document.createElement('script');
            script.src = `https://itunes.apple.com/search?term=${encodeURIComponent(query)}&entity=song&limit=1&country=${CONFIG.STORE_COUNTRY}&callback=${cbName}`;
            window[cbName] = function(data) {
                cleanupScript(script, cbName);
                if (data && data.results && data.results.length > 0) {
                    callback(data.results[0].artworkUrl100.replace('100x100bb', '1200x1200bb')); 
                } else callback(null);
            };
            script.onerror = () => { cleanupScript(script, cbName); callback(null); };
            document.body.appendChild(script);
        }

        function cleanupScript(script, cbName) {
            if(document.body.contains(script)) document.body.removeChild(script);
            delete window[cbName];
        }

        window.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
