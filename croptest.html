<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Albums - Edge AI & Saliency</title>
    
    <style>
        body {
            margin: 0; padding: 0; background-color: #000; overflow: hidden;
            font-family: sans-serif; user-select: none; -webkit-user-select: none;
        }
        #container {
            position: relative; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden; background-color: #000; cursor: pointer; 
        }
        #bg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-size: cover; background-position: center;
            filter: blur(120px) brightness(0.9);
            transform: scale(1.4); z-index: 1; opacity: 0; transition: opacity 1s;
        }
        #art-wrapper {
            position: relative; z-index: 10; width: 90vmin; height: 90vmin;
            display: flex; box-shadow: 0 0 120px 10px rgba(0,0,0,0.5);
            border-radius: 24px; overflow: hidden; 
        }
        #album-art {
            width: 100%; height: 100%; object-fit: contain; 
            opacity: 0; transition: opacity 1s;
        }
        .crop-highlight {
            position: absolute; border: 4px solid #00ff00;
            box-shadow: 0 0 10px rgba(0,0,0,0.8);
            box-sizing: border-box; pointer-events: none; z-index: 20;
            opacity: 0; transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #debug-log {
            position: absolute; 
            top: calc(10px + env(safe-area-inset-top)); 
            left: max(10px, env(safe-area-inset-left)); 
            z-index: 999;
            color: #00ff00; font-family: monospace; font-size: 12px;
            background: rgba(0,0,0,0.8); padding: 8px; border-radius: 8px;
            pointer-events: none; max-width: 80vw; word-wrap: break-word;
        }
        #status-light {
            position: absolute; 
            top: calc(15px + env(safe-area-inset-top)); 
            right: max(15px, env(safe-area-inset-right)); 
            z-index: 1000;
            width: 16px; height: 16px; border-radius: 50%;
            background-color: #555; border: 2px solid #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
            cursor: pointer;
        }
        .ai-online { background-color: #00ff00 !important; box-shadow: 0 0 15px #00ff00 !important; }
        .ai-offline { background-color: #ff0000 !important; box-shadow: 0 0 15px #ff0000 !important; }
        .ai-waiting { background-color: #ffaa00 !important; box-shadow: 0 0 15px #ffaa00 !important; }
    </style>
</head>
<body>

    <div id="debug-log">Starting up...</div>
    <div id="status-light" title="Tap to restart" onclick="location.reload()"></div>

    <div id="container">
        <div id="bg-layer"></div>
        <div id="art-wrapper">
            <img id="album-art" src="" alt="" crossorigin="anonymous" />
        </div>
        <video id="wake-video" playsinline loop muted width="1" height="1" style="opacity: 0; position: absolute;">
            <source src="data:video/mp4;base64,AAAAHGZ0eXBNNEVAAAAAAAEAAAAAAABtZGF0AAAAEAAACAAAABAAAAA=" type="video/mp4">
        </video>
    </div>

    <script>
        const CONFIG = {
            CSV_FILENAME: 'applemusic-3.csv', 
            CSV_INTERVAL_MS: 500000, 
            STORE_COUNTRY: 'il', 
            FADE_DURATION: 700, 
            BLACK_HOLD_DURATION: 200, 
            LAST_FM_API_KEY: '7a767d135623f2bac77d858b3a6d9aba',
            LAST_FM_USER: 'Noamsadi95',
            LAST_FM_POLL_INTERVAL: 5000, 
            LAST_FM_TIMEOUT_MS: 20 * 60 * 1000
        };

        let intervals = { lastFm: null, csv: null };
        let state = {
            startupDone: false, currentMode: 'STARTUP', csvTrackList: [], csvIndex: 0,
            displayedLastFmTrack: null, lastFmTrackStartTime: 0, lastFmActivityTime: Date.now(), isTransitioning: false
        };

        let faceDetector = null;

        function setLight(status) {
            const light = document.getElementById('status-light');
            light.className = ''; 
            if (status) light.classList.add('ai-' + status);
        }

        function logStatus(msg) {
            console.log("[Status]", msg);
            const logEl = document.getElementById('debug-log');
            if (logEl) logEl.innerText = msg;
        }

        async function initFaceDetector() {
            if (faceDetector) return;
            logStatus("Loading Edge AI...");
            setLight('waiting');
            try {
                // The +esm flag forces jsDelivr to inject proper CORS headers for Safari
                const visionModule = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm");
                const { FaceDetector, FilesetResolver } = visionModule;
                
                // Using unpkg for the WASM binary path as it often has more reliable cross-origin headers
                const visionResolver = await FilesetResolver.forVisionTasks(
                    "https://unpkg.com/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                faceDetector = await FaceDetector.createFromOptions(visionResolver, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite",
                        delegate: "GPU"
                    },
                    runningMode: "IMAGE"
                });
                logStatus("Edge AI Ready");
                setLight('online');
            } catch (error) {
                console.error("Face Detector failed to load:", error);
                logStatus("AI Offline. Using Saliency only.");
                setLight('offline');
            }
        }

        async function init() {
            logStatus("Initializing...");
            requestWakeLock();
            
            // Load Face Detector first so it's ready for the first image
            await initFaceDetector();

            await loadCSV(); 
            checkLastFm(); 
            intervals.lastFm = setInterval(checkLastFm, CONFIG.LAST_FM_POLL_INTERVAL);
            setupInputListeners();
        }

        function setupInputListeners() {
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 's') triggerShuffle();
            });
            document.getElementById('container').addEventListener('click', (e) => {
                if(e.target.id !== 'status-light') triggerShuffle();
            });
        }

        function triggerShuffle() {
            if (state.isTransitioning) return;
            logStatus("Shuffle tapped!");
            if (state.currentMode !== 'CSV') startCsvMode();
            else {
                if (intervals.csv) clearInterval(intervals.csv);
                triggerCsvUpdate();
                intervals.csv = setInterval(triggerCsvUpdate, CONFIG.CSV_INTERVAL_MS);
            }
        }

        async function requestWakeLock() {
            try { if ('wakeLock' in navigator) await navigator.wakeLock.request('screen'); } catch (err) {}
        }

        function performVisualTransition(imageUrl, onSuccessCallback) {
            if (state.isTransitioning) return false; 
            state.isTransitioning = true;
            logStatus("Downloading Image...");

            // Clear old highlights instantly
            document.querySelectorAll('.crop-highlight').forEach(el => el.remove());

            const displayLoader = new Image();
            displayLoader.crossOrigin = "anonymous"; 
            displayLoader.src = imageUrl;

            displayLoader.onload = () => {
                const imgEl = document.getElementById('album-art');
                const bgEl = document.getElementById('bg-layer');
                if (!imgEl || !bgEl) return; 

                imgEl.src = imageUrl;
                bgEl.style.backgroundImage = `url('${imageUrl}')`;

                imgEl.style.opacity = '0';
                bgEl.style.opacity = '0';

                setTimeout(() => {
                    requestAnimationFrame(() => {
                        imgEl.style.opacity = '1';
                        bgEl.style.opacity = '1';
                        setTimeout(() => { 
                            state.isTransitioning = false;
                            if(onSuccessCallback) onSuccessCallback();
                            
                            // Call our local analysis engine
                            analyzeVisuals(displayLoader, displayLoader.width, displayLoader.height);
                        }, CONFIG.FADE_DURATION);
                    });
                }, 100); 
            };
            displayLoader.onerror = () => {
                state.isTransitioning = false;
                logStatus("Error: Image failed to load.");
                setTimeout(triggerShuffle, 1000); 
            };
            return true;
        }

        async function analyzeVisuals(imgObj, imgW, imgH) {
            setLight('waiting');
            
            // 1. Try Face Detection First (if loaded)
            if (faceDetector) {
                const detections = faceDetector.detect(imgObj);
                
                if (detections.detections.length > 0) {
                    logStatus(`Found ${detections.detections.length} Face(s)`);
                    setLight('online');
                    
                    // Sort by confidence, limit to top 3
                    const faces = detections.detections
                        .sort((a, b) => b.categories[0].score - a.categories[0].score)
                        .slice(0, 3);

                    faces.forEach(face => {
                        const box = face.boundingBox;
                        const padding = box.width * 0.2; // 20% padding
                        const squareSize = Math.max(box.width, box.height) + (padding * 2);
                        const centerX = box.originX + (box.width / 2);
                        const centerY = box.originY + (box.height / 2);
                        
                        drawHighlight(centerX, centerY, squareSize, imgW, imgH);
                    });
                    return; // Exit early if faces are found
                }
            }

            // 2. Fallback: Pure JS Classical Saliency
            logStatus("No faces. Running Saliency...");
            runClassicalSaliency(imgObj, imgW, imgH);
        }

        function runClassicalSaliency(imgObj, originalW, originalH) {
            const processSize = 100; // Small grid for fast processing
            const canvas = document.createElement('canvas');
            canvas.width = processSize;
            canvas.height = processSize;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            
            ctx.drawImage(imgObj, 0, 0, processSize, processSize);
            const imgData = ctx.getImageData(0, 0, processSize, processSize);
            const data = imgData.data;
            
            const scores = new Float32Array(processSize * processSize);
            const luma = new Float32Array(processSize * processSize);

            // Pass 1: Luminance & Saturation
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                const idx = i / 4;
                
                luma[idx] = (0.299 * r + 0.587 * g + 0.114 * b);
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const saturation = max - min;
                
                scores[idx] += saturation * 0.5; 
            }

            // Pass 2: Edge Density Approximate (Sobel-like)
            for (let y = 1; y < processSize - 1; y++) {
                for (let x = 1; x < processSize - 1; x++) {
                    const idx = y * processSize + x;
                    
                    const up = luma[idx - processSize];
                    const down = luma[idx + processSize];
                    const left = luma[idx - 1];
                    const right = luma[idx + 1];
                    
                    const edgeScore = Math.abs(luma[idx] - up) + Math.abs(luma[idx] - down) + 
                                      Math.abs(luma[idx] - left) + Math.abs(luma[idx] - right);
                                      
                    scores[idx] += edgeScore * 1.5; // Weight edges heavily
                }
            }

            // Pass 3: Pool regions to find the "hottest" areas
            const regions = [];
            const windowSize = 25; // 25x25 window (represents 25% of the image size)
            const step = 10;
            
            for (let y = 0; y <= processSize - windowSize; y += step) {
                for (let x = 0; x <= processSize - windowSize; x += step) {
                    let regionScore = 0;
                    for (let wy = 0; wy < windowSize; wy++) {
                        for (let wx = 0; wx < windowSize; wx++) {
                            regionScore += scores[(y + wy) * processSize + (x + wx)];
                        }
                    }
                    regions.push({ x, y, score: regionScore });
                }
            }

            regions.sort((a, b) => b.score - a.score);

            // Extract top 3 non-overlapping regions
            const topRegions = [];
            for (const region of regions) {
                let overlap = false;
                for (const selected of topRegions) {
                    // Simple AABB overlap check
                    if (region.x < selected.x + windowSize && region.x + windowSize > selected.x &&
                        region.y < selected.y + windowSize && region.y + windowSize > selected.y) {
                        overlap = true; break;
                    }
                }
                if (!overlap) {
                    topRegions.push(region);
                    if (topRegions.length >= 3) break;
                }
            }

            setLight('online');
            if (topRegions.length > 0) {
                topRegions.forEach(region => {
                    const scale = originalW / processSize;
                    const centerX = (region.x + windowSize/2) * scale;
                    const centerY = (region.y + windowSize/2) * scale;
                    const squareSize = (windowSize * scale) * 1.2; 
                    
                    drawHighlight(centerX, centerY, squareSize, originalW, originalH);
                });
            } else {
                // Ultimate fallback: Center square
                drawHighlight(originalW/2, originalH/2, Math.min(originalW, originalH)*0.5, originalW, originalH);
            }
        }

        function drawHighlight(centerX, centerY, targetSize, imgW, imgH) {
            const highlightElement = document.createElement('div');
            highlightElement.className = 'crop-highlight';
            document.getElementById('art-wrapper').appendChild(highlightElement);
            applyAndClampBox(centerX, centerY, targetSize, targetSize, imgW, imgH, highlightElement);
        }

        function applyAndClampBox(centerX, centerY, targetWidth, targetHeight, imgW, imgH, el) {
            let startX = centerX - (targetWidth / 2);
            let startY = centerY - (targetHeight / 2);
            
            startX = Math.max(0, Math.min(imgW - targetWidth, startX));
            startY = Math.max(0, Math.min(imgH - targetHeight, startY));
            
            if (el) {
                el.style.left = (startX / imgW) * 100 + '%';
                el.style.top = (startY / imgH) * 100 + '%';
                el.style.width = (targetWidth / imgW) * 100 + '%';
                el.style.height = (targetHeight / imgH) * 100 + '%';
                el.style.opacity = '1';
            }
        }

        function startCsvMode() {
            if (state.currentMode === 'CSV' && intervals.csv) return;
            logStatus("CSV Mode Started");
            state.currentMode = 'CSV';
            if (intervals.csv) clearInterval(intervals.csv);
            triggerCsvUpdate(); 
            intervals.csv = setInterval(triggerCsvUpdate, CONFIG.CSV_INTERVAL_MS);
        }

        async function checkLastFm() {
            const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${CONFIG.LAST_FM_USER}&api_key=${CONFIG.LAST_FM_API_KEY}&format=json&limit=1`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.recenttracks && data.recenttracks.track.length > 0) {
                    const track = data.recenttracks.track[0];
                    const id = track.name + ' - ' + track.artist['#text'];
                    const playing = track['@attr'] && track['@attr'].nowplaying === 'true';
                    if (!state.startupDone) {
                        state.startupDone = true;
                        if (playing) switchToLastFm(track, id); else startCsvMode();
                        return;
                    }
                    if (playing) {
                        state.lastFmActivityTime = Date.now();
                        if (state.currentMode === 'CSV' || id !== state.displayedLastFmTrack) switchToLastFm(track, id);
                    } else if (state.currentMode === 'LASTFM' && (Date.now() - state.lastFmActivityTime > CONFIG.LAST_FM_TIMEOUT_MS)) {
                        startCsvMode();
                    }
                }
            } catch (e) { if (!state.startupDone) { state.startupDone = true; startCsvMode(); } }
        }

        function switchToLastFm(track, id) {
            if (intervals.csv) clearInterval(intervals.csv);
            state.currentMode = 'LASTFM';
            state.lastFmTrackStartTime = Date.now();
            logStatus("Playing: " + track.name);
            fetchItunesBySearch(track.name, track.artist['#text'], track.album['#text'], (url) => {
                if (!url && track.image) {
                    const img = track.image.find(i => i.size === 'extralarge') || track.image[track.image.length - 1];
                    url = img ? img['#text'] : null;
                }
                if (url) performVisualTransition(`https://wsrv.nl/?url=${encodeURIComponent(url)}`, () => { state.displayedLastFmTrack = id; });
            });
        }

        async function loadCSV() {
            try {
                const res = await fetch(CONFIG.CSV_FILENAME);
                if (!res.ok) throw new Error();
                const text = await res.text();
                const lines = text.split('\n').filter(l => l.trim() !== '');
                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                const idIdx = headers.indexOf('id');
                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(c => c.replace(/^"|"$/g, '').trim());
                    if (cols[idIdx]) state.csvTrackList.push({ id: cols[idIdx] });
                }
                state.csvTrackList.sort(() => Math.random() - 0.5);
                logStatus("CSV Loaded.");
            } catch (e) { logStatus("Using Fallback."); state.csvTrackList.push({ id: '617154241' }); }
        }

        function triggerCsvUpdate() {
            if (state.currentMode !== 'CSV' || !state.csvTrackList.length) return;
            const track = state.csvTrackList[state.csvIndex];
            fetchItunesById(track.id, (url) => {
                if (url) performVisualTransition(`https://wsrv.nl/?url=${encodeURIComponent(url)}`, null);
                else setTimeout(triggerCsvUpdate, 1000);
            });
            state.csvIndex = (state.csvIndex + 1) % state.csvTrackList.length;
        }

        function fetchItunesById(id, cb) {
            const n = 'cb' + Math.floor(Math.random() * 1e6);
            const s = document.createElement('script');
            s.src = `https://itunes.apple.com/lookup?id=${id}&country=${CONFIG.STORE_COUNTRY}&callback=${n}`;
            window[n] = (d) => { cleanup(s, n); cb(d.results?.[0]?.artworkUrl100?.replace('100x100bb', '1200x1200bb')); };
            s.onerror = () => { cleanup(s, n); cb(null); };
            document.body.appendChild(s);
        }

        function fetchItunesBySearch(t, a, al, cb) {
            const n = 'cb' + Math.floor(Math.random() * 1e6);
            const s = document.createElement('script');
            s.src = `https://itunes.apple.com/search?term=${encodeURIComponent(a+' '+t)}&entity=song&limit=1&country=${CONFIG.STORE_COUNTRY}&callback=${n}`;
            window[n] = (d) => { cleanup(s, n); cb(d.results?.[0]?.artworkUrl100?.replace('100x100bb', '1200x1200bb')); };
            s.onerror = () => { cleanup(s, n); cb(null); };
            document.body.appendChild(s);
        }

        function cleanup(s, n) { if(document.body.contains(s)) document.body.removeChild(s); delete window[n]; }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>