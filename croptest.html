<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Albums - Cloud AI Saliency</title>
    
    <style>
        body {
            margin: 0; padding: 0; background-color: #000; overflow: hidden;
            font-family: sans-serif; user-select: none; -webkit-user-select: none;
        }
        #container {
            position: relative; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden; background-color: #000; cursor: pointer; 
        }
        #bg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-size: cover; background-position: center;
            filter: blur(120px) brightness(0.9);
            transform: scale(1.4); z-index: 1; opacity: 0; transition: opacity 1s;
        }
        #art-wrapper {
            position: relative; z-index: 10; width: 90vmin; height: 90vmin;
            display: flex; box-shadow: 0 0 120px 10px rgba(0,0,0,0.5);
            border-radius: 24px; overflow: hidden; 
        }
        #album-art {
            width: 100%; height: 100%; object-fit: contain; 
            opacity: 0; transition: opacity 1s;
        }
        #crop-highlight {
            position: absolute; border: 4px solid red;
            box-shadow: 0 0 10px rgba(0,0,0,0.5), 0 0 0 9999px rgba(0, 0, 0, 0.4);
            box-sizing: border-box; pointer-events: none; z-index: 20;
            opacity: 0; transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #debug-log {
            position: absolute; top: 10px; left: 10px; z-index: 999;
            color: #00ff00; font-family: monospace; font-size: 12px;
            background: rgba(0,0,0,0.6); padding: 8px; border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="debug-log">Starting up...</div>

    <div id="container">
        <div id="bg-layer"></div>
        <div id="art-wrapper">
            <img id="album-art" src="" alt="" crossorigin="anonymous" />
            <div id="crop-highlight"></div>
        </div>
        <video id="wake-video" playsinline loop muted width="1" height="1" style="opacity: 0; position: absolute;">
            <source src="data:video/mp4;base64,AAAAHGZ0eXBNNEVAAAAAAAEAAAAAAABtZGF0AAAAEAAACAAAABAAAAA=" type="video/mp4">
        </video>
    </div>

    <script>
        const CONFIG = {
            // We removed the hardcoded token to satisfy GitHub's security rules
            HF_API_TOKEN: localStorage.getItem('hf_token') || '', 
            HF_MODEL_ENDPOINT: "https://api-inference.huggingface.co/models/facebook/detr-resnet-50",
            
            CSV_FILENAME: 'applemusic-3.csv', 
            CSV_INTERVAL_MS: 500000, 
            STORE_COUNTRY: 'il', 
            FADE_DURATION: 700, 
            BLACK_HOLD_DURATION: 200, 
            LAST_FM_API_KEY: '7a767d135623f2bac77d858b3a6d9aba',
            LAST_FM_USER: 'Noamsadi95',
            LAST_FM_POLL_INTERVAL: 5000, 
            LAST_FM_TIMEOUT_MS: 20 * 60 * 1000
        };

        let intervals = { lastFm: null, csv: null };
        let state = {
            startupDone: false, currentMode: 'STARTUP', csvTrackList: [], csvIndex: 0,
            displayedLastFmTrack: null, lastFmTrackStartTime: 0, lastFmActivityTime: Date.now(), isTransitioning: false
        };

        function logStatus(msg) {
            console.log("[Status]", msg);
            const logEl = document.getElementById('debug-log');
            if (logEl) logEl.innerText = msg;
        }

        async function init() {
            logStatus("Initializing...");

            // If no token is saved, ask the user for it
            if (!CONFIG.HF_API_TOKEN) {
                const token = prompt("Please enter your Hugging Face API Token (hf_...):");
                if (token) {
                    localStorage.setItem('hf_token', token);
                    CONFIG.HF_API_TOKEN = token;
                } else {
                    logStatus("ERROR: API Token required.");
                    return;
                }
            }

            requestWakeLock();
            await loadCSV(); 
            checkLastFm(); 
            intervals.lastFm = setInterval(checkLastFm, CONFIG.LAST_FM_POLL_INTERVAL);
            setupInputListeners();
        }

        function setupInputListeners() {
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 's') triggerShuffle();
            });
            document.getElementById('container').addEventListener('click', () => {
                triggerShuffle();
            });
        }

        function triggerShuffle() {
            if (state.isTransitioning) return;
            logStatus("Shuffle tapped!");
            if (state.currentMode !== 'CSV') startCsvMode();
            else {
                if (intervals.csv) clearInterval(intervals.csv);
                triggerCsvUpdate();
                intervals.csv = setInterval(triggerCsvUpdate, CONFIG.CSV_INTERVAL_MS);
            }
        }

        async function requestWakeLock() {
            try { if ('wakeLock' in navigator) await navigator.wakeLock.request('screen'); } catch (err) {}
        }

        function performVisualTransition(imageUrl, onSuccessCallback) {
            if (state.isTransitioning) return false; 
            state.isTransitioning = true;
            logStatus("Downloading Image...");

            const displayLoader = new Image();
            displayLoader.src = imageUrl;

            displayLoader.onload = () => {
                logStatus("Image ready. Displaying...");
                const imgEl = document.getElementById('album-art');
                const bgEl = document.getElementById('bg-layer');
                const cropHighlight = document.getElementById('crop-highlight');

                if (!imgEl || !bgEl) return; 

                imgEl.style.opacity = '0';
                bgEl.style.opacity = '0';
                if(cropHighlight) {
                    cropHighlight.style.opacity = '0';
                    cropHighlight.style.borderColor = 'yellow'; 
                }

                setTimeout(() => {
                    imgEl.src = imageUrl;
                    bgEl.style.backgroundImage = `url('${imageUrl}')`;

                    requestAnimationFrame(() => {
                        imgEl.style.opacity = '1';
                        bgEl.style.opacity = '1';
                        
                        setTimeout(() => { 
                            state.isTransitioning = false;
                            if(onSuccessCallback) onSuccessCallback();
                            analyzeWithCloudAI(imageUrl, displayLoader.width, displayLoader.height, cropHighlight);
                        }, CONFIG.FADE_DURATION);
                    });
                }, 100); 
            };

            displayLoader.onerror = () => {
                state.isTransitioning = false;
                logStatus("Error: Display image failed to load.");
                setTimeout(triggerShuffle, 1000); 
            };
            return true;
        }

        async function analyzeWithCloudAI(imageUrl, imgW, imgH, highlightElement) {
            logStatus("Sending to Cloud AI...");
            try {
                const proxyUrl = `https://wsrv.nl/?url=${encodeURIComponent(imageUrl)}`;
                const imageResponse = await fetch(proxyUrl);
                const imageBlob = await imageResponse.blob();

                const hfResponse = await fetch(CONFIG.HF_MODEL_ENDPOINT, {
                    headers: { Authorization: `Bearer ${CONFIG.HF_API_TOKEN}` },
                    method: "POST",
                    body: imageBlob,
                });

                const result = await hfResponse.json();

                if (result.error && result.error.includes("is currently loading")) {
                    const waitTime = Math.ceil(result.estimated_time || 20);
                    logStatus(`Cloud AI waking up... retrying in ${waitTime}s`);
                    setTimeout(() => analyzeWithCloudAI(imageUrl, imgW, imgH, highlightElement), waitTime * 1000);
                    return;
                }

                if (Array.isArray(result) && result.length > 0) {
                    const best = result.sort((a, b) => b.score - a.score)[0];
                    logStatus(`AI Focused on: ${best.label} (${Math.round(best.score * 100)}%)`);

                    const box = best.box;
                    const centerX = box.xmin + ((box.xmax - box.xmin) / 2);
                    const centerY = box.ymin + ((box.ymax - box.ymin) / 2);

                    const targetWidth = imgW * 0.5;
                    const targetHeight = imgH * 0.5;

                    applyAndClampBox(centerX, centerY, targetWidth, targetHeight, imgW, imgH, highlightElement);

                } else {
                    logStatus("No subjects detected. Using center.");
                    applyAndClampBox(imgW/2, imgH/2, imgW*0.5, imgH*0.5, imgW, imgH, highlightElement);
                }
            } catch (error) {
                console.error("Cloud AI Error:", error);
                logStatus("Cloud AI Connection Failed.");
            }
        }

        function applyAndClampBox(centerX, centerY, targetWidth, targetHeight, imgW, imgH, el) {
            let startX = centerX - (targetWidth / 2);
            let startY = centerY - (targetHeight / 2);

            startX = Math.max(0, Math.min(imgW - targetWidth, startX));
            startY = Math.max(0, Math.min(imgH - targetHeight, startY));

            const leftPct = (startX / imgW) * 100;
            const topPct = (startY / imgH) * 100;
            const widthPct = (targetWidth / imgW) * 100;
            const heightPct = (targetHeight / imgH) * 100;

            if (el) {
                el.style.borderColor = 'red';
                el.style.left = leftPct + '%';
                el.style.top = topPct + '%';
                el.style.width = widthPct + '%';
                el.style.height = heightPct + '%';
                el.style.opacity = '1';
            }
        }

        function startCsvMode() {
            if (state.currentMode === 'CSV' && intervals.csv) return;
            logStatus("Starting CSV Mode");
            state.currentMode = 'CSV';
            if (intervals.csv) clearInterval(intervals.csv);
            triggerCsvUpdate(); 
            intervals.csv = setInterval(triggerCsvUpdate, CONFIG.CSV_INTERVAL_MS);
        }

        async function checkLastFm() {
            const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${CONFIG.LAST_FM_USER}&api_key=${CONFIG.LAST_FM_API_KEY}&format=json&limit=1`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.recenttracks && data.recenttracks.track && data.recenttracks.track.length > 0) {
                    const track = data.recenttracks.track[0];
                    const trackIdentifier = track.name + ' - ' + track.artist['#text'];
                    const isNowPlaying = track['@attr'] && track['@attr'].nowplaying === 'true';

                    if (!state.startupDone) {
                        state.startupDone = true;
                        if (isNowPlaying) switchToLastFm(track, trackIdentifier);
                        else startCsvMode();
                        return; 
                    }

                    if (isNowPlaying) {
                        state.lastFmActivityTime = Date.now();
                        if (state.currentMode === 'CSV') {
                            if (intervals.csv) clearInterval(intervals.csv);
                            switchToLastFm(track, trackIdentifier);
                        } else if (trackIdentifier !== state.displayedLastFmTrack) {
                            switchToLastFm(track, trackIdentifier);
                        }
                    } else if (state.currentMode === 'LASTFM' && (Date.now() - state.lastFmActivityTime > CONFIG.LAST_FM_TIMEOUT_MS)) {
                        startCsvMode();
                    }
                }
            } catch (error) {
                if (!state.startupDone) { state.startupDone = true; startCsvMode(); }
            }
        }

        function switchToLastFm(track, trackIdentifier) {
            state.currentMode = 'LASTFM';
            state.lastFmTrackStartTime = Date.now();
            logStatus("Last.fm: " + track.name);

            const albumName = (track.album && track.album['#text']) ? track.album['#text'] : null;

            fetchItunesBySearch(track.name, track.artist['#text'], albumName, (itunesImageUrl) => {
                let finalImage = itunesImageUrl;
                if (!finalImage && track.image) {
                    const imgObj = track.image.find(i => i.size === 'extralarge') || track.image[track.image.length - 1];
                    if (imgObj) finalImage = imgObj['#text'];
                }
                if (finalImage) performVisualTransition(finalImage, () => { state.displayedLastFmTrack = trackIdentifier; });
                else logStatus("No artwork found.");
            });
        }

        async function loadCSV() {
            try {
                const response = await fetch(CONFIG.CSV_FILENAME);
                if (!response.ok) throw new Error("Fetch failed"); 
                parseCSV(await response.text());
                logStatus("CSV Loaded.");
            } catch (error) { 
                logStatus("CSV Blocked. Using Fallback.");
                state.csvTrackList.push({ id: '617154241' });
            }
        }

        function parseCSV(text) {
            const lines = text.split('\n').filter(l => l.trim() !== '');
            if (lines.length < 2) return;
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            const idIndex = headers.indexOf('id');
            if (idIndex === -1) return;
            const splitRegex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/;

            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(splitRegex).map(c => c.replace(/^"|"$/g, '').trim());
                if (cols.length > idIndex) state.csvTrackList.push({ id: cols[idIndex] });
            }
            if (state.csvTrackList.length > 0) {
                for (let i = state.csvTrackList.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [state.csvTrackList[i], state.csvTrackList[j]] = [state.csvTrackList[j], state.csvTrackList[i]];
                }
            }
        }

        function triggerCsvUpdate() {
            if (state.currentMode !== 'CSV' || state.csvTrackList.length === 0) return;
            const track = state.csvTrackList[state.csvIndex];
            logStatus("Fetching Apple Music...");
            fetchItunesById(track.id, (url) => {
                if (url) performVisualTransition(url);
                else {
                     state.csvIndex = (state.csvIndex + 1) % state.csvTrackList.length;
                     setTimeout(triggerCsvUpdate, 1000); 
                }
            });
            state.csvIndex = (state.csvIndex + 1) % state.csvTrackList.length;
        }

        function fetchItunesById(appleId, callback) {
            const cbName = 'cb_id_' + Math.floor(Math.random() * 100000);
            const script = document.createElement('script');
            script.src = `https://itunes.apple.com/lookup?id=${appleId}&country=${CONFIG.STORE_COUNTRY}&callback=${cbName}`;
            window[cbName] = function(data) {
                cleanupScript(script, cbName);
                if (data && data.results && data.results.length > 0) callback(data.results[0].artworkUrl100.replace('100x100bb', '1200x1200bb')); 
                else callback(null);
            };
            script.onerror = () => { cleanupScript(script, cbName); callback(null); };
            document.body.appendChild(script);
        }

        function fetchItunesBySearch(trackName, artistName, albumName, callback) {
            const cbName = 'cb_search_' + Math.floor(Math.random() * 100000);
            let query = artistName + ' ' + trackName + (albumName ? ' ' + albumName : '');
            const script = document.createElement('script');
            script.src = `https://itunes.apple.com/search?term=${encodeURIComponent(query)}&entity=song&limit=1&country=${CONFIG.STORE_COUNTRY}&callback=${cbName}`;
            window[cbName] = function(data) {
                cleanupScript(script, cbName);
                if (data && data.results && data.results.length > 0) callback(data.results[0].artworkUrl100.replace('100x100bb', '1200x1200bb')); 
                else callback(null);
            };
            script.onerror = () => { cleanupScript(script, cbName); callback(null); };
            document.body.appendChild(script);
        }

        function cleanupScript(script, cbName) {
            if(document.body.contains(script)) document.body.removeChild(script);
            delete window[cbName];
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
