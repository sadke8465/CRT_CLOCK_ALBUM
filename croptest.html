<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Albums - Cloud AI Saliency</title>
    
    <style>
        body {
            margin: 0; padding: 0; background-color: #000; overflow: hidden;
            font-family: sans-serif; user-select: none; -webkit-user-select: none;
        }
        #container {
            position: relative; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden; background-color: #000; cursor: pointer; 
        }
        #bg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-size: cover; background-position: center;
            filter: blur(120px) brightness(0.9);
            transform: scale(1.4); z-index: 1; opacity: 0; transition: opacity 1s;
        }
        #art-wrapper {
            position: relative; z-index: 10; width: 90vmin; height: 90vmin;
            display: flex; box-shadow: 0 0 120px 10px rgba(0,0,0,0.5);
            border-radius: 24px; overflow: hidden; 
        }
        #album-art {
            width: 100%; height: 100%; object-fit: contain; 
            opacity: 0; transition: opacity 1s;
        }
        #crop-highlight {
            position: absolute; border: 4px solid red;
            box-shadow: 0 0 10px rgba(0,0,0,0.5), 0 0 0 9999px rgba(0, 0, 0, 0.4);
            box-sizing: border-box; pointer-events: none; z-index: 20;
            opacity: 0; transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #debug-log {
            position: absolute; top: 10px; left: 10px; z-index: 999;
            color: #00ff00; font-family: monospace; font-size: 12px;
            background: rgba(0,0,0,0.8); padding: 8px; border-radius: 8px;
            pointer-events: none; max-width: 80vw; word-wrap: break-word;
        }
        #status-light {
            position: absolute; top: 15px; right: 15px; z-index: 1000;
            width: 16px; height: 16px; border-radius: 50%;
            background-color: #555; border: 2px solid #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
            cursor: pointer;
        }
        .ai-online { background-color: #00ff00 !important; box-shadow: 0 0 15px #00ff00 !important; }
        .ai-offline { background-color: #ff0000 !important; box-shadow: 0 0 15px #ff0000 !important; }
        .ai-waiting { background-color: #ffaa00 !important; box-shadow: 0 0 15px #ffaa00 !important; }
    </style>
</head>
<body>

    <div id="debug-log">Starting up...</div>
    <div id="status-light" title="Tap to reset token" onclick="resetToken()"></div>

    <div id="container">
        <div id="bg-layer"></div>
        <div id="art-wrapper">
            <img id="album-art" src="" alt="" crossorigin="anonymous" />
            <div id="crop-highlight"></div>
        </div>
        <video id="wake-video" playsinline loop muted width="1" height="1" style="opacity: 0; position: absolute;">
            <source src="data:video/mp4;base64,AAAAHGZ0eXBNNEVAAAAAAAEAAAAAAABtZGF0AAAAEAAACAAAABAAAAA=" type="video/mp4">
        </video>
    </div>

    <script>
        const CONFIG = {
            HF_API_TOKEN: localStorage.getItem('hf_token') || '', 
            HF_MODEL_ENDPOINT: "https://api-inference.huggingface.co/models/facebook/detr-resnet-50",
            
            CSV_FILENAME: 'applemusic-3.csv', 
            CSV_INTERVAL_MS: 500000, 
            STORE_COUNTRY: 'il', 
            FADE_DURATION: 700, 
            BLACK_HOLD_DURATION: 200, 
            LAST_FM_API_KEY: '7a767d135623f2bac77d858b3a6d9aba',
            LAST_FM_USER: 'Noamsadi95',
            LAST_FM_POLL_INTERVAL: 5000, 
            LAST_FM_TIMEOUT_MS: 20 * 60 * 1000
        };

        let intervals = { lastFm: null, csv: null };
        let state = {
            startupDone: false, currentMode: 'STARTUP', csvTrackList: [], csvIndex: 0,
            displayedLastFmTrack: null, lastFmTrackStartTime: 0, lastFmActivityTime: Date.now(), isTransitioning: false
        };

        function resetToken() {
            if(confirm("Reset Hugging Face Token?")) {
                localStorage.removeItem('hf_token');
                location.reload();
            }
        }

        function setLight(status) {
            const light = document.getElementById('status-light');
            light.className = ''; 
            if (status) light.classList.add('ai-' + status);
        }

        function logStatus(msg) {
            console.log("[Status]", msg);
            const logEl = document.getElementById('debug-log');
            if (logEl) logEl.innerText = msg;
        }

        async function init() {
            logStatus("Initializing...");
            if (!CONFIG.HF_API_TOKEN) {
                const token = prompt("Enter Hugging Face API Token (hf_...):");
                if (token && token.trim() !== '') { 
                    localStorage.setItem('hf_token', token.trim()); 
                    CONFIG.HF_API_TOKEN = token.trim(); 
                } else {
                    logStatus("ERROR: API Token required.");
                    setLight('offline');
                    return;
                }
            }
            requestWakeLock();
            await loadCSV(); 
            checkLastFm(); 
            intervals.lastFm = setInterval(checkLastFm, CONFIG.LAST_FM_POLL_INTERVAL);
            setupInputListeners();
        }

        function setupInputListeners() {
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 's') triggerShuffle();
            });
            document.getElementById('container').addEventListener('click', (e) => {
                if(e.target.id !== 'status-light') triggerShuffle();
            });
        }

        function triggerShuffle() {
            if (state.isTransitioning) return;
            logStatus("Shuffle tapped!");
            if (state.currentMode !== 'CSV') startCsvMode();
            else {
                if (intervals.csv) clearInterval(intervals.csv);
                triggerCsvUpdate();
                intervals.csv = setInterval(triggerCsvUpdate, CONFIG.CSV_INTERVAL_MS);
            }
        }

        async function requestWakeLock() {
            try { if ('wakeLock' in navigator) await navigator.wakeLock.request('screen'); } catch (err) {}
        }

        function performVisualTransition(imageUrl, onSuccessCallback) {
            if (state.isTransitioning) return false; 
            state.isTransitioning = true;
            logStatus("Downloading Image...");

            const displayLoader = new Image();
            // CRITICAL FIX: Tell browser to request CORS headers so we can draw it to a canvas later
            displayLoader.crossOrigin = "anonymous"; 
            displayLoader.src = imageUrl;

            displayLoader.onload = () => {
                const imgEl = document.getElementById('album-art');
                const bgEl = document.getElementById('bg-layer');
                const cropHighlight = document.getElementById('crop-highlight');
                if (!imgEl || !bgEl) return; 

                imgEl.src = imageUrl;
                bgEl.style.backgroundImage = `url('${imageUrl}')`;

                imgEl.style.opacity = '0';
                bgEl.style.opacity = '0';
                if(cropHighlight) cropHighlight.style.opacity = '0';

                setTimeout(() => {
                    requestAnimationFrame(() => {
                        imgEl.style.opacity = '1';
                        bgEl.style.opacity = '1';
                        setTimeout(() => { 
                            state.isTransitioning = false;
                            if(onSuccessCallback) onSuccessCallback();
                            
                            // Pass the loaded Image object directly to the AI Engine
                            analyzeWithCloudAI(displayLoader, displayLoader.width, displayLoader.height, cropHighlight);
                        }, CONFIG.FADE_DURATION);
                    });
                }, 100); 
            };
            displayLoader.onerror = () => {
                state.isTransitioning = false;
                logStatus("Error: Image failed to load.");
                setTimeout(triggerShuffle, 1000); 
            };
            return true;
        }

        // --- THE CANVAS "SCREENSHOT" AI ENGINE ---
        async function analyzeWithCloudAI(imgObj, imgW, imgH, highlightElement) {
            logStatus("Compressing for AI...");
            setLight('waiting');
            try {
                // 1. Draw the image to a hidden canvas to bypass network block
                const canvas = document.createElement('canvas');
                const maxSize = 600; // Compress down to max 600px
                let w = imgW, h = imgH;
                
                if (w > maxSize || h > maxSize) {
                    if (w > h) { h = Math.round((h * maxSize) / w); w = maxSize; } 
                    else { w = Math.round((w * maxSize) / h); h = maxSize; }
                }
                canvas.width = w; canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(imgObj, 0, 0, w, h);

                // 2. Convert Canvas to a binary Blob
                const imageBlob = await new Promise((resolve, reject) => {
                    canvas.toBlob((blob) => {
                        if (blob) resolve(blob);
                        else reject(new Error("Canvas conversion blocked by Apple CORS."));
                    }, 'image/jpeg', 0.8);
                });

                logStatus("Sending to Cloud AI...");

                // 3. Post Blob to Hugging Face
                const hfResponse = await fetch(CONFIG.HF_MODEL_ENDPOINT, {
                    headers: { Authorization: `Bearer ${CONFIG.HF_API_TOKEN}` },
                    method: "POST",
                    body: imageBlob,
                });

                // Catch Token / Auth Errors
                if (hfResponse.status === 401) {
                    localStorage.removeItem('hf_token');
                    throw new Error("Invalid API Token. Tap red light to reset.");
                }

                if (!hfResponse.ok) {
                    throw new Error(`HF Server Error: ${hfResponse.status}`);
                }

                const result = await hfResponse.json();

                // Handle AI Loading State
                if (result.error && result.error.includes("is currently loading")) {
                    const waitTime = Math.ceil(result.estimated_time || 20);
                    logStatus(`AI Waking up... (${waitTime}s)`);
                    setLight('waiting');
                    setTimeout(() => analyzeWithCloudAI(imgObj, imgW, imgH, highlightElement), waitTime * 1000);
                    return;
                }

                // 4. Process Detected Objects
                if (Array.isArray(result) && result.length > 0) {
                    setLight('online');
                    const best = result.sort((a, b) => b.score - a.score)[0];
                    logStatus(`AI Focused on: ${best.label} (${Math.round(best.score * 100)}%)`);
                    
                    const box = best.box;
                    const centerX = box.xmin + ((box.xmax - box.xmin) / 2);
                    const centerY = box.ymin + ((box.ymax - box.ymin) / 2);
                    
                    // We must scale the coordinates back up since we compressed the image
                    const scaleX = imgW / w;
                    const scaleY = imgH / h;
                    
                    applyAndClampBox(centerX * scaleX, centerY * scaleY, imgW * 0.5, imgH * 0.5, imgW, imgH, highlightElement);
                } else {
                    logStatus("No subjects. Centering.");
                    setLight('online');
                    applyAndClampBox(imgW/2, imgH/2, imgW*0.5, imgH*0.5, imgW, imgH, highlightElement);
                }
            } catch (error) {
                console.error("Cloud AI Error:", error);
                logStatus(`AI Failed: ${error.message}`);
                setLight('offline');
            }
        }

        function applyAndClampBox(centerX, centerY, targetWidth, targetHeight, imgW, imgH, el) {
            let startX = centerX - (targetWidth / 2);
            let startY = centerY - (targetHeight / 2);
            startX = Math.max(0, Math.min(imgW - targetWidth, startX));
            startY = Math.max(0, Math.min(imgH - targetHeight, startY));
            
            if (el) {
                el.style.left = (startX / imgW) * 100 + '%';
                el.style.top = (startY / imgH) * 100 + '%';
                el.style.width = (targetWidth / imgW) * 100 + '%';
                el.style.height = (targetHeight / imgH) * 100 + '%';
                el.style.opacity = '1';
                el.style.borderColor = 'red';
            }
        }

        function startCsvMode() {
            if (state.currentMode === 'CSV' && intervals.csv) return;
            logStatus("CSV Mode Started");
            state.currentMode = 'CSV';
            if (intervals.csv) clearInterval(intervals.csv);
            triggerCsvUpdate(); 
            intervals.csv = setInterval(triggerCsvUpdate, CONFIG.CSV_INTERVAL_MS);
        }

        async function checkLastFm() {
            const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${CONFIG.LAST_FM_USER}&api_key=${CONFIG.LAST_FM_API_KEY}&format=json&limit=1`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.recenttracks && data.recenttracks.track.length > 0) {
                    const track = data.recenttracks.track[0];
                    const id = track.name + ' - ' + track.artist['#text'];
                    const playing = track['@attr'] && track['@attr'].nowplaying === 'true';
                    if (!state.startupDone) {
                        state.startupDone = true;
                        if (playing) switchToLastFm(track, id); else startCsvMode();
                        return;
                    }
                    if (playing) {
                        state.lastFmActivityTime = Date.now();
                        if (state.currentMode === 'CSV' || id !== state.displayedLastFmTrack) switchToLastFm(track, id);
                    } else if (state.currentMode === 'LASTFM' && (Date.now() - state.lastFmActivityTime > CONFIG.LAST_FM_TIMEOUT_MS)) {
                        startCsvMode();
                    }
                }
            } catch (e) { if (!state.startupDone) { state.startupDone = true; startCsvMode(); } }
        }

        function switchToLastFm(track, id) {
            if (intervals.csv) clearInterval(intervals.csv);
            state.currentMode = 'LASTFM';
            state.lastFmTrackStartTime = Date.now();
            logStatus("Playing: " + track.name);
            fetchItunesBySearch(track.name, track.artist['#text'], track.album['#text'], (url) => {
                if (!url && track.image) {
                    const img = track.image.find(i => i.size === 'extralarge') || track.image[track.image.length - 1];
                    url = img ? img['#text'] : null;
                }
                // Push through proxy to ensure CORS doesn't block the canvas later
                if (url) performVisualTransition(`https://wsrv.nl/?url=${encodeURIComponent(url)}`, () => { state.displayedLastFmTrack = id; });
            });
        }

        async function loadCSV() {
            try {
                const res = await fetch(CONFIG.CSV_FILENAME);
                if (!res.ok) throw new Error();
                const text = await res.text();
                const lines = text.split('\n').filter(l => l.trim() !== '');
                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                const idIdx = headers.indexOf('id');
                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(c => c.replace(/^"|"$/g, '').trim());
                    if (cols[idIdx]) state.csvTrackList.push({ id: cols[idIdx] });
                }
                state.csvTrackList.sort(() => Math.random() - 0.5);
                logStatus("CSV Loaded.");
            } catch (e) { logStatus("Using Fallback."); state.csvTrackList.push({ id: '617154241' }); }
        }

        function triggerCsvUpdate() {
            if (state.currentMode !== 'CSV' || !state.csvTrackList.length) return;
            const track = state.csvTrackList[state.csvIndex];
            fetchItunesById(track.id, (url) => {
                // Push through proxy to ensure CORS doesn't block the canvas later
                if (url) performVisualTransition(`https://wsrv.nl/?url=${encodeURIComponent(url)}`, null);
                else setTimeout(triggerCsvUpdate, 1000);
            });
            state.csvIndex = (state.csvIndex + 1) % state.csvTrackList.length;
        }

        function fetchItunesById(id, cb) {
            const n = 'cb' + Math.floor(Math.random() * 1e6);
            const s = document.createElement('script');
            s.src = `https://itunes.apple.com/lookup?id=${id}&country=${CONFIG.STORE_COUNTRY}&callback=${n}`;
            window[n] = (d) => { cleanup(s, n); cb(d.results?.[0]?.artworkUrl100?.replace('100x100bb', '1200x1200bb')); };
            s.onerror = () => { cleanup(s, n); cb(null); };
            document.body.appendChild(s);
        }

        function fetchItunesBySearch(t, a, al, cb) {
            const n = 'cb' + Math.floor(Math.random() * 1e6);
            const s = document.createElement('script');
            s.src = `https://itunes.apple.com/search?term=${encodeURIComponent(a+' '+t)}&entity=song&limit=1&country=${CONFIG.STORE_COUNTRY}&callback=${n}`;
            window[n] = (d) => { cleanup(s, n); cb(d.results?.[0]?.artworkUrl100?.replace('100x100bb', '1200x1200bb')); };
            s.onerror = () => { cleanup(s, n); cb(null); };
            document.body.appendChild(s);
        }

        function cleanup(s, n) { if(document.body.contains(s)) document.body.removeChild(s); delete window[n]; }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
